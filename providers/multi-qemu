#!/usr/bin/env ruby
# SPDX-License-Identifier: MulanPSL-2.0+
# Copyright (c) 2020 Huawei Technologies Co., Ltd. All rights reserved.
# frozen_string_literal: true

require 'fileutils'
require 'optparse'
require 'json'
require 'securerandom'

require_relative 'lib/common'
require_relative '../lib/mq_client'

opt = {}
options = OptionParser.new do |opts|
  opts.banner = 'Usage: multi-qemu -n -c -q'

  opts.separator ''
  opts.on('-n HOSTNAME_PREFIX', '--name HOSTNAME_PREFIX', 'format: $tbox_group.$HOSTNAME') do |name|
    opt['hostname_prefix'] = name
  end

  opts.on('-c count', '--count count', 'how many VM do you need') do |num|
    opt['nr_vm'] = num
  end

  opts.on('-q queues', '--queues queues', 'separated by ","') do |queues|
    opt['queues'] = queues
  end

  opts.on('-l log_dir', '--log_dir log_dir', 'directory for save qemu log') do |dir|
    opt['log_dir'] = dir
  end

  opts.on('-i index', '--index index', 'index of multi-qemu, used for safe-stop') do |index|
    opt['index'] = index
  end

  opts.on_tail('-h', '--help', 'show this message') do
    puts opts
    exit
  end
end

if ARGV.size.zero?
  puts options
  exit 1
end

options.parse!(ARGV)

# Run multiple QEMU in parallel
PWD      = Dir.pwd
HOSTNAME = opt['hostname_prefix'] || "vm-2p8g.#{ENV['HOSTNAME']}"
NR_VM    = opt['nr_vm'] || 1
QUEUES   = opt['queues'] || "#{ENV['HOSTNAME']}.#{RUBY_PLATFORM.split('-')[0]}"
LOG_DIR  = opt['log_dir'] || '/srv/cci/serial/logs'
INDEX    = opt['index']

UUID = SecureRandom.uuid
SUITE_FILE = "/tmp/#{ENV['HOSTNAME']}/suite"
SAFE_STOP_FILE = "/tmp/#{ENV['HOSTNAME']}/safe-stop"
RESTART_FILE = "/tmp/#{ENV['HOSTNAME']}/restart/#{UUID}"
RESTART_LOCK_FILE = "/tmp/#{ENV['HOSTNAME']}/restart/lock"

SCHED_HOST = ENV['LKP_SERVER'] || '172.17.0.1'
SCHED_PORT = ENV['LKP_CGI_PORT'] || '3000'
MQ_HOST = ENV['MQ_HOST'] || ENV['LKP_SERVER'] || '172.17.0.1'
MQ_PORT = ENV['MQ_PORT'] || 5672

def main(hostname)
  check_mem_quota

  start_time = record_runtime_log(hostname)
  start_qemu(hostname)
  record_runtime_log(hostname, start_time: start_time, is_start: false)
end

def record_runtime_log(hostname, start_time: Time.new, is_start: true)
  log_file = "#{LOG_DIR}/#{hostname}"
  if is_start
    File.open(log_file, 'w') do |f|
      # fluentd refresh time is 1s
      # let fluentd to monitor this file first
      sleep(2)
      f.puts "\n#{start_time.strftime('%Y-%m-%d %H:%M:%S')} starting QEMU"
    end
    return start_time
  end

  duration = ((Time.new - start_time) / 60).round(2)
  File.open(log_file, 'a') do |f|
    f.puts "\nTotal QEMU duration:  #{duration} minutes"
  end
  # Allow fluentd sufficient time to read the contents of the log file
  sleep(2)
end

def start_qemu(hostname)
  pwd_hostname = File.join(PWD, hostname)
  FileUtils.mkdir_p(pwd_hostname) unless File.exist?(pwd_hostname)
  FileUtils.cd(pwd_hostname)
  system(
    { 'hostname' => hostname, 'queues' => "#{QUEUES},#{hostname}", 'log_dir' => LOG_DIR, 'UUID' => UUID },
    ENV['CCI_SRC'] + '/providers/qemu.sh'
  )
end

def loop_main(hostname, thr)
  loop do
    begin
      thr.exit if File.exist?(SAFE_STOP_FILE)
      main(hostname)
    rescue StandardError => e
      puts e.backtrace
      # if an exception occurs, request the next time after 30 seconds
      sleep 25
    ensure
      sleep 5
    end
  end
end

def save_running_suite
  return unless INDEX

  FileUtils.mkdir_p("/tmp/#{ENV['HOSTNAME']}") unless File.exist?("/tmp/#{ENV['HOSTNAME']}")
  f = File.new(SUITE_FILE, 'a')
  f.flock(File::LOCK_EX)
  f.puts("#{ENV['suite']}-#{INDEX}")
ensure
  f&.flock(File::LOCK_UN)
  f&.close
end

def delete_running_suite
  return [] unless INDEX

  f1 = File.new(SUITE_FILE)
  f1.flock(File::LOCK_EX)

  arr = []
  f1.each_line do |line|
    arr << line.chomp
  end
  arr.uniq
  arr.delete("#{HOSTNAME}-#{INDEX}")

  f2 = File.new(SUITE_FILE, 'w')
  arr.each do |line|
    f2.puts line
  end
  return arr
ensure
  f2&.close
  f1&.flock(File::LOCK_UN)
  f1&.close
end

def loop_reboot_vm(hostname)
  loop do
    begin
      reboot_vm(hostname)
    rescue StandardError => e
      puts e.backtrace
      sleep 5
    end
  end
end

def reboot_vm(hostname)
  mq = MQClient.new(MQ_HOST, MQ_PORT)
  queue = mq.queue(hostname, { :durable => true })
  queue.subscribe({ :block => true, :manual_ack => true }) do |info, _pro, msg|
    puts msg
    machine_info = JSON.parse(msg)
    job_id = machine_info['job_id']
    res, msg = reboot('vm', job_id)
    report_event(machine_info, res, msg)
    mq.ack(info)
  end
end

# msg:
# { "type" => "safe-stop/restart",
#   "hostname" => "all" or "taishan.*--a11,taishan.*--a12,...",
#   "commit_id" => "xxxxxx"
# }
def monitor_mq_message(threads)
  mq = MQClient.new(MQ_HOST, MQ_PORT)
  queue = mq.fanout_queue('multi-manage', "#{HOSTNAME}-manage")
  queue.subscribe({ :block => true }) do |_info, _pro, msg|
    deal_mq_manage_message(threads, msg)
  end
end

def deal_mq_manage_message(threads, msg)
  puts msg
  msg = JSON.parse(msg)
  return unless fit_me?(msg)

  case msg['type']
  when 'safe-stop'
    manage_safe_stop(threads)
  when 'restart'
    manage_restart(threads, msg)
  else
    puts 'deal mq manage message: unknow type message'
  end
rescue StandardError => e
  puts e.backtrace.inspect
end

def fit_me?(msg)
  return true if msg['hostname'] == 'all'
  return true if msg['hostname'].to_s.include?(ENV['HOSTNAME'])

  return false
end

def manage_safe_stop(threads)
  File.new(SAFE_STOP_FILE, 'w')
  threads['manage'].exit
end

def manage_restart(threads, msg)
  update_code(msg['commit_id'])
  File.new(RESTART_FILE, 'w')
  threads.each do |name, thr|
    next if name == 'manage'

    puts "restart manage exit the thread: #{name}"
    thr.exit
  end
  threads['manage'].exit
end

def update_code(commit_id)
  # if there is no commit_id
  # the code is not updated
  return unless commit_id

  dir = "/tmp/#{ENV['HOSTNAME']}/restart"
  FileUtils.mkdir_p(dir) unless File.exist?(dir)

  f = File.new(RESTART_LOCK_FILE, 'a+')
  f.flock(File::LOCK_EX)
  return if f.readlines[0].to_s.chomp == commit_id

  update_restart_lock(commit_id)

  cmd = "cd #{ENV['CCI_SRC']};git pull;git reset --hard #{commit_id}"
  puts cmd
  system(cmd)
ensure
  f&.flock(File::LOCK_UN)
end

def update_restart_lock(commit_id)
  File.open(RESTART_LOCK_FILE, 'w') do |f|
    f.puts commit_id
  end
end

def manage(threads)
  loop do
    begin
      puts 'manage thread begin'
      monitor_mq_message(threads)
    rescue StandardError => e
      puts e.backtrace
      sleep 5
    end
  end
end

def multiqemu
  reboot_thr = Thread.new do
    loop_reboot_vm(HOSTNAME)
  end

  threads = {}
  NR_VM.to_i.times do |i|
    thr = Thread.new do
      loop_main("#{HOSTNAME}-#{i}", thr)
    end
    threads[i] = thr
  end

  manage_thr = Thread.new do
    manage(threads.merge({ 'manage' => manage_thr }))
  end

  threads.each do |_, thr|
    thr.join
  end

  manage_thr.exit
  reboot_thr.exit
  puts 'all threads exit'

  safe_stop
  puts "#{UUID} exit"
end

def safe_stop
  return unless INDEX
  return unless File.exist?(SAFE_STOP_FILE)

  running_suites = delete_running_suite

  # kill lkp-tests sleep process
  # so the multi-qemu job will over soon
  # only do this when there is no running multi-qemu in this testbox
  cmd = "kill -9 `ps -ef|grep sleep|grep #{ENV['runtime']}|grep -v grep|awk '{print $2}'`"
  if running_suites.empty?
    puts cmd
    system(cmd)
  end

  system("systemctl stop #{ENV['suite']}-#{INDEX}.service")
end

if $PROGRAM_NAME == __FILE__
  save_running_suite
  multiqemu
end
